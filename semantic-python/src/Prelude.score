{
  type <- \name -> \super -> \slots ->
    #record { __name: name, __super: super, __slots: slots };

  instance <- \class -> \prim -> \slots ->
    #record { __super: class, __prim: prim, __slots: slots };

  // object's superclass is type itself
  object <- type "object" type #record{};

  // These classes' __new__ slots are incorrect (the first parameter should be the `str`
  // and `bool` values themselves, not object), but until semantic/#362 is fixed, we can't
  // use `rec` in the prelude, so for True and False below we call instance manually.
  str <- type "str" object #record { __new__: \prim -> instance object prim #record{} };
  bool <- type "bool" object #record { __new__: \prim -> instance object prim #record{} };

  True <- instance bool #true #record {};
  False <- instance bool #false #record {};

  // We will fill in the actual definition of these operators
  // pending the presence of more eliminators.
  not <- \val -> if val.__prim then False else True;

  NoneType <- type "None" object #record { __new__: \prim -> instance #unit prim #record{} };
  None <- NoneType.__slots.__new__ #unit;

  getitem <- \super -> \item -> \attr ->
    if item.slots.?attr then item.slots.attr else #unit;

  #record { type: type
          , object: object
          , str: str
          , bool: bool
          , False: False
          , True: True
          , not: not
          , NoneType: NoneType
          , None: None
          , getitem: getitem}
}
